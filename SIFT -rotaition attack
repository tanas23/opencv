#include "stdafx.h"

#include <opencv2/opencv.hpp>



#pragma comment(lib, "opencv_world341d.lib")

using namespace cv;

using namespace std;



static const double pi = 3.141592653589793;



class KeyPoint_use {

    public:

        float x;

        float y;

        int flugs;

};



vector<KeyPoint_use> kp_initial(vector<KeyPoint> keypoint){



    vector<KeyPoint_use> kp;



    for(int i=0;i<keypoint.size();i++){

        kp[i].x = keypoint[i].pt.x;

        kp[i].y = keypoint[i].pt.y;

        kp[i].flugs = 0;

    }



    return kp;

}



int kp_same_num(vector<KeyPoint> keypoint1, vector<KeyPoint> keypoint2){

    int num=0;

    vector<KeyPoint>::iterator itk,itk2;



    for(itk = keypoint1.begin(); itk!=keypoint1.end(); ++itk) {

        for(itk2 = keypoint2.begin(); itk2!=keypoint2.end(); ++itk2){

            //cout << itk->pt.x << ":" << itk->pt.y << endl;

            //cout << itk2->pt.x << ":" << itk2->pt.y << endl;

            int x1 = (int)itk->pt.x;

            int x2 = (int)itk2->pt.x;

            int y1 = (int)itk->pt.y;

            int y2 = (int)itk2->pt.y;

            if((x1 == x2 || x1+1 == x2 || x1-1 == x2) && (y1 == y2 || y1+1 == y2 || y1-1 == y2)){

                num++;

                break;

            }

        }

    }



    return num;



}



Mat rot_img(Mat src_img,float angle, float scale){



    Point2f center(src_img.cols * 0.5, src_img.rows * 0.5);

    const Mat affine_matrix = getRotationMatrix2D(center, angle, scale);



    Mat dst_img;

    warpAffine(src_img, dst_img, affine_matrix, src_img.size(),INTER_LANCZOS4);



    return dst_img;

}



vector<KeyPoint> feature_get(Mat src_img){



    vector<KeyPoint> keypoint;



    // SIFT�܂���SURF���g���ꍇ�͂������Ăяo���D

    

    // FeatureDetector�I�u�W�F�N�g�̐���

    Ptr<FeatureDetector> detector = FeatureDetector::create("SIFT");

    //auto detector = AKAZE::create();

    // �����_�������i�[���邽�߂̕ϐ�



    // �����_���o�̎��s

    detector->detect(src_img, keypoint);



    return keypoint;

}



Mat feature_write(Mat src_img, vector<KeyPoint> keypoint, vector<KeyPoint> keypoint2,int origin_flug){





    Mat dst_img = src_img;

    int flugs = 0;

    vector<KeyPoint>::iterator itk,itk2;

    Scalar color(255,0,0);

    Scalar color2(0,255,0);

    Scalar color3(0,0,255);



    for(itk = keypoint.begin(); itk!=keypoint.end(); ++itk) {

        flugs = 0;

        for(itk2 = keypoint2.begin(); itk2!=keypoint2.end(); ++itk2){

            int x1 = (int)itk->pt.x;

            int x2 = (int)itk2->pt.x;

            int y1 = (int)itk->pt.y;

            int y2 = (int)itk2->pt.y;

            if((x1 == x2 || x1+1 == x2 || x1-1 == x2) && (y1 == y2 || y1+1 == y2 || y1-1 == y2)) {

                flugs = 1;

                break;

            }

        }



        if(flugs==1){

            circle(dst_img, itk->pt, itk->size, color2, 1, CV_AA);

        }else{

            if(origin_flug != 1) {

                circle(dst_img, itk->pt, itk->size, color, 1, CV_AA);

            }

        }

    }



    for(itk2 = keypoint2.begin(); itk2!=keypoint2.end(); ++itk2) {

        flugs = 0;

        for(itk = keypoint.begin(); itk!=keypoint.end(); ++itk) {

            int x1 = (int)itk->pt.x;

            int x2 = (int)itk2->pt.x;

            int y1 = (int)itk->pt.y;

            int y2 = (int)itk2->pt.y;

            if((x1 == x2 || x1+1 == x2 || x1-1 == x2) && (y1 == y2 || y1+1 == y2 || y1-1 == y2)) {

                flugs = 1;

                break;

            }

        }



        if(flugs == 1){



        }else{

            if(origin_flug != 1) {

                circle(dst_img, itk2->pt, itk2->size, color3, 1, CV_AA);

            }

        }

    }

    return dst_img;

}



Mat feature_write_dot(Mat src_img, vector<KeyPoint> keypoint, vector<KeyPoint> keypoint2){



    Mat dst_img = src_img;

    int flugs = 0;

    float x,y;

    vector<KeyPoint>::iterator itk,itk2;

    Scalar color(255,0,0);

    for(itk = keypoint.begin(); itk!=keypoint.end(); ++itk) {

        x = itk->pt.x;

        y = itk->pt.y;

        flugs = 0;

        for(itk2 = keypoint2.begin(); itk2!=keypoint2.end(); ++itk2){

            if(itk->pt.x==itk2->pt.x && itk->pt.y==itk2->pt.y){

                flugs = 1;

            }

        }



        if(flugs==1){

            //circle(dst_img, itk->pt, 2, color2, 1, CV_AA);

        }else{

            dst_img.at<Vec3b>(x,y)[0] = 255;

            dst_img.at<Vec3b>(x,y)[1] = 0;

            dst_img.at<Vec3b>(x,y)[2] = 0;

            //circle(img, itk->pt, 1, color, -1);

            //circle(dst_img, itk->pt, /*itk->size*/2, color, 1, CV_AA);

            //if(itk->angle>=0) {

            //Point pt2(itk->pt.x + cos(itk->angle)*itk->size, itk->pt.y + sin(itk->angle)*itk->size);

            //line(img, itk->pt, pt2, color, 1, CV_AA);

            //}

        }

    }



    return dst_img;

}



Mat mono_img(Mat img){



    cout << "mono_img" << endl;



    Mat dst = img;

    int coler[3],luminance;



    //cout << "cols = " << img.cols << endl;

    //cout << "rows = " << img.rows << endl;



    for(int y = 0; y < img.rows; ++y){

        for(int x = 0; x < img.cols; ++x){

            //cout << "rows=" << y << endl;

            //cout << "cols=" << x << endl;

            coler[0] = img.data[ y * img.step + x * img.elemSize() + 0 ];

            coler[1] = img.data[ y * img.step + x * img.elemSize() + 1 ];

            coler[2] = img.data[ y * img.step + x * img.elemSize() + 2 ];



            luminance =  0.298912 * coler[2] + 0.586611 * coler[1] + 0.114478 * coler[0];

            coler[0] = luminance;

            coler[1] = luminance;

            coler[2] = luminance;



            dst.data[ y * img.step + x * img.elemSize() + 0 ] = coler[0];

            dst.data[ y * img.step + x * img.elemSize() + 1 ] = coler[1];

            dst.data[ y * img.step + x * img.elemSize() + 2 ] = coler[2];

        }

    }



    return dst;

}



float mse_img(Mat img, Mat img2){



    cout << "mse_img" << endl;



    int x,y;

    float mse=0.0;

    for(x=0;x<img.cols;x++){

        for(y=0;y<img.rows;y++){

            mse += (img.data[ x * img.step + y * img.elemSize()] - img2.data[ x * img2.step + y * img2.elemSize()]);

        }

    }

    mse = mse / (img.rows * img.cols);

    return mse;

}



float psnr_img(Mat img, Mat img2){



    cout << "psnr_img" << endl;



    float psnr,mse;



    img = mono_img(img);

    img2 = mono_img(img2);



    mse = mse_img(img,img2);

    psnr = 10 * log10( (255 * 255) / mse);



    return psnr;



}



void display_kp(vector<KeyPoint> keypoint1, vector<KeyPoint> keypoint2, float angle){

    cout << "keypoint1 num = " << keypoint1.size() << endl;

    cout << "keypoint2 num = " << keypoint2.size() << endl;

    cout << "keypoint1.pt.x = " << keypoint1[0].pt.x << endl;

    cout << "keypoint1.pt.y = " << keypoint1[0].pt.y << endl;

    cout << "same keypoint num = " << kp_same_num(keypoint1,keypoint2) << endl;



    getchar();

}



int main(void){

    float angle;

    vector<KeyPoint> keypoint1,keypoint2;

    int kp1_num,kp2_num,same_num,add_num,del_num;

	char in_file[256], out_file[256];



	printf("入力ファイル名:");

	scanf_s("%s",in_file,256);

	printf("倍率:");

	scanf_s("%f",&angle);

	printf("出力ファイル名:");

	scanf_s("%s",out_file,256);



    

    Mat img = imread(in_file,1);

    Mat img2 = imread(in_file,1);

   

    if(img.data == NULL) return -1;

    if(img2.data == NULL) return -1;



    Mat img_base(512, 512, CV_8UC3, Scalar(255));

    Mat img2_base(512, 512, CV_8UC3, Scalar(255));



    Mat mat = (Mat_<double>(2,3)<<1.0, 0.0, (img_base.cols / 2) - (img.cols / 2) , 0.0, 1.0, (img_base.rows / 2) - (img.rows / 2));



 

    warpAffine(img, img_base, mat, img_base.size());

    warpAffine(img2, img2_base, mat, img2_base.size());



  

    img2_base = rot_img(img2_base,angle,1);





    keypoint1 = feature_get(img_base);

    keypoint2 = feature_get(img2_base);



    //vector<KeyPoint_use> kp1,kp2;



    //kp1 = kp_initial(keypoint1);

    //kp2 = kp_initial(keypoint2);



    //display_kp(keypoint1,keypoint2,angle);



   

    Mat dst_img = feature_write(img_base,keypoint1,keypoint2,1);

    Mat dst_img2 = feature_write(img2_base,keypoint2,keypoint1,0);



    kp1_num = keypoint1.size();

    kp2_num = keypoint2.size();

    same_num = kp_same_num(keypoint1,keypoint2);

    del_num = kp1_num - same_num;

    add_num = kp2_num - same_num;



    cout << "kp1_num:" << kp1_num << endl;

    cout << "kp2_num:" << kp2_num << endl;

    cout << "same kp num:" << same_num << endl;

    cout << "delete kp num:" << del_num << endl;

    cout << "add kp num:" << add_num << endl;





  

    Mat base(max(dst_img.rows,dst_img2.rows), dst_img.cols + dst_img2.cols, CV_8UC3);

    Mat roi1(base, Rect(0 , 0 , dst_img.cols , dst_img.rows) );

    dst_img.copyTo(roi1);

    Mat roi2( base,Rect(dst_img.cols , 0 , dst_img2.cols , dst_img2.rows) );

    dst_img2.copyTo(roi2);





    namedWindow("SIFT Features", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);

    imshow("SIFT Features", base);

    waitKey(0);

    imwrite(out_file,base);





    return 0;



}
